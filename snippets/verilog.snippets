snippet mod
	module ${1:`Filename("$1")`} (
		${2:// IOPorts}
	);
		
		${3}
	
	endmodule
	
snippet modp
	module ${1:`Filename("$1")`} #(
		parameter
		${2:// paramDef}
	) (
		${3:// IOPorts}
	);
		
		${4}

	endmodule

snippet modf
	module ${1:`Filename("$1")`} (

	);

	// clock & reset -------------------
	input            clk;
	input            rst_n;
	${1}


	/*AUTOWIRE*/
    // Automatically generate undefined instances output/inout port
	// End of automitics


	/*AUTOREG*/
    // Automatically generate register for undeclared output
	// End of automitics

	endmodule


snippet tb
	module ${1:`Filename("$1")`};
		
		reg clk,rst_;
		${2}
		
		always #5 clk = ~clk;
		
		initial begin
			clk=0;
			rst_=1;
			#10 rsr_=0;
			#10 rst_=1;

			
			
			#10000 $stop;
		end
		
	endmodule

snippet alw
	always @* begin
		${1}
	end

snippet alwa
	always @(posedge clk, negedge rst_n) begin
		if(!rst_n)${1}
	end

snippet alws
	always @(posedge clk) begin
		${1}
	end

snippet begin
	begin
		${1}
	end${2}
snippet case
	case(${1:switch})
		${2}
	endcase
snippet pos
	(posedge clk,
snippet neg
	negedge rst_)
snippet gen
	genvar ${1:i};
	generate
		${2}
	endgenerate

snippet for
	for(${1:i} = ${2:0}; $1${3: < 10}; $1 = $1 + 1) begin
		${4:/* code */}
	end
snippet ini
	initial begin
		${1}
	end

snippet stm
	/*STM:${1}*/
snippet arg
	/*AUTOARG*/
snippet inst
	/*AUTOINST*/
snippet autowire
	/*AUTOWIRE*/
snippet autoreg
	/*AUTOREG*/
snippet autoarg
	/*AUTOARG*/
snippet autoinst
	/*AUTOINST*/

snippet apb
	// AMBA apb bus ----------------------------------
	input                  pclk;
	input                  presetn;
	input                  psel;
	input                  penable;
	input                  pwrite;
	input  [${1:/*addr width*/}:0]          paddr;
	input  [31:0]          pwdata;
	output [31:0]          prdata;
	output                 pready;
	output                 pslverr;
	${2}

snippet axi4
	// AXI4 port ${1:/* seq number */} parameter
	parameter  AXI$1_ID_WIDTH   = ${2:/*id width*/},
	           AXI$1_ADDR_WIDTH = ${3:/* addr width */},
			   AXI$1_DAT_WIDTH  = ${4:/* data width */};
	localparam AXI$1_STRB_WIDTH = AXI$1_DAT_WIDTH / 8;
	// AMBA AXI4 bus  ----------------------------------
	// global signal
	input                        axi$1_aclk;
	input                        axi$1_aresetn;
	// write address channel
	input  [AXI$1_ID_WIDTH-1:0]   axi$1_awid;
	input  [AXI$1_ADDR_WIDTH-1:0] axi$1_awaddr;
	input  [7:0]                 axi$1_awlen;
	input  [2:0]                 axi$1_awsize;
	input  [1:0]                 axi$1_awburst;
	input                        axi$1_awlock;
	input  [3:0]                 axi$1_awcache;
	input  [2:0]                 axi$1_awprot;
	input  [3:0]                 axi$1_awqos;
	input  [3:0]                 axi$1_awregion;
	input                        axi$1_awvalid;
	output                       axi$1_awready;
	// write data channel
	input  [AXI$1_DAT_WIDTH-1:0]  axi$1_wdata;
	input  [AXI$1_STRB_WIDTH-1:0] axi$1_wstrb;
	input                        axi$1_wlast;
	input                        axi$1_wvalid;
	output                       axi$1_wready;
	// write response channel
	output [AXI$1_ID_WIDTH-1:0]   axi$1_bid;
	output [1:0]                 axi$1_bresp;
	output                       axi$1_bvalid;
	input                        axi$1_bready;
	// read address channel
	input  [AXI$1_ID_WIDTH-1:0]   axi$1_arid;
	input  [AXI$1_ADDR_WIDTH-1:0] axi$1_araddr;
	input  [7:0]                 axi$1_arlen;
	input  [2:0]                 axi$1_arsize;
	input  [1:0]                 axi$1_arburst;
	input                        axi$1_arlock;
	input  [3:0]                 axi$1_arcache;
	input  [2:0]                 axi$1_arprot;
	input  [3:0]                 axi$1_arqos;
	input  [3:0]                 axi$1_arregion;
	input                        axi$1_arvalid;
	output                       axi$1_arready;
	// read data channel
	input  [$2:0]                axi$1_rid;
	input  [$4:0]               axi$1_rdata;
	output [1:0]                 axi$1_rresp;
	input                        axi$1_rlast;
	input                        axi$1_rvalid;
	output                       axi$1_rready;
	// low-power control
	input                        axi$1_csysreq;
	output                       axi$1_csysack;
	output                       axi$1_cactive;
	${5}


snippet axi3
	// AXI3 port ${1:/* seq number */} parameter
	parameter  AXI$1_ID_WIDTH   = ${2:/*id width*/},
	           AXI$1_ADDR_WIDTH = ${3:/* addr width */},
			   AXI$1_DAT_WIDTH  = ${4:/* data width */};
	localparam AXI$1_STRB_WIDTH = AXI$1_DAT_WIDTH / 8;
	// AMBA AXI3 bus ----------------------------------
	// global signal
	input                        axi$1_aclk;
	input                        axi$1_aresetn;
	// write address channel
	input  [AXI$1_ID_WIDTH-1:0]   axi$1_awid;
	input  [AXI$1_ADDR_WIDTH-1:0] axi$1_awaddr;
	input  [3:0]                 axi$1_awlen;
	input  [2:0]                 axi$1_awsize;
	input  [1:0]                 axi$1_awburst;
	input  [1:0]                 axi$1_awlock;
	input  [3:0]                 axi$1_awcache;
	input  [2:0]                 axi$1_awprot;
	input                        axi$1_awvalid;
	output                       axi$1_awready;
	// write data channel
	input  [AXI$1_ID_WIDTH-1:0]   axi$1_wid;
	input  [AXI$1_DAT_WIDTH-1:0]  axi$1_wdata;
	input  [AXI$1_STRB_WIDTH-1:0] axi$1_wstrb;
	input                        axi$1_wlast;
	input                        axi$1_wvalid;
	output                       axi$1_wready;
	// write response channel
	output [AXI$1_ID_WIDTH-1:0]   axi$1_bid;
	output [1:0]                 axi$1_bresp;
	output                       axi$1_bvalid;
	input                        axi$1_bready;
	// read address channel
	input  [AXI$1_ID_WIDTH-1:0]   axi$1_arid;
	input  [AXI$1_ADDR_WIDTH-1:0] axi$1_araddr;
	input  [7:0]                 axi$1_arlen;
	input  [2:0]                 axi$1_arsize;
	input  [1:0]                 axi$1_arburst;
	input                        axi$1_arlock;
	input  [3:0]                 axi$1_arcache;
	input  [2:0]                 axi$1_arprot;
	input                        axi$1_arvalid;
	output                       axi$1_arready;
	// read data channel
	input  [$2:0]                axi$1_rid;
	input  [$4:0]                axi$1_rdata;
	output [1:0]                 axi$1_rresp;
	input                        axi$1_rlast;
	input                        axi$1_rvalid;
	output                       axi$1_rready;
	// low-power control
	input                        axi$1_csysreq;
	output                       axi$1_csysack;
	output                       axi$1_cactive;
	${5}

