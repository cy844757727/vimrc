snippet mod
	module ${1:`Filename("$1")`} (
		${2:// IOPorts}
	);
		
		${3}
	
	endmodule
	
snippet modp
	module ${1:`Filename("$1")`} #(
		parameter
		${2:// paramDef}
	) (
		${3:// IOPorts}
	);
		
		${4}

	endmodule

snippet tb
	module ${1:`Filename("$1")`};
		
		reg clk,rst_;
		${2}
		
		always #5 clk = ~clk;
		
		initial begin
			clk=0;
			rst_=1;
			#10 rsr_=0;
			#10 rst_=1;

			
			
			#10000 $stop;
		end
		
	endmodule

snippet alw
	always @* begin
		${1}
	end

snippet alwa
	always @(posedge clk, negedge rst_) begin
		if(!rst_)${1}
	end

snippet alws
	always @(posedge clk) begin
		${1}
	end

snippet begin
	begin
		${1}
	end${2}
snippet case
	case(${1:switch})
		${2}
	endcase
snippet pos
	(posedge clk,
snippet neg
	negedge rst_)
snippet gen
	genvar ${1:i};
	generate
		${2}
	endgenerate

snippet for
	for(${1:i} = ${2:0}; $1${3: < 10}; $1 = $1 + 1) begin
		${5:/* code */}
	end
snippet ini
	initial begin
		${1}
	end

snippet apb
	// AMBA apb bus ----------------------------------
	input                  pclk;
	input                  presetn;
	input                  psel;
	input                  penable;
	input                  pwrite;
	input  [${1:/*addr width*/}:0]          paddr;
	input  [31:0]          pwdata;
	output [31:0]          prdata;
	output                 pready;
	output                 pslverr;


snippet axi4
	// AMBA AXI bus versison:4 ----------------------------------
	// global signal
	input                       axi${1:/*seq num*/}_aclk;
	input                       axi$1_aresetn;
	// write address channel
	input  [${2:/*id width*/}:0]               axi$1_awid;
	input  [${3:/*addr width*/}:0]               axi$1_awaddr;
	input  [7:0]                axi$1_awlen;
	input  [2:0]                axi$1_awsize;
	input  [1:0]                axi$1_awburst;
	input                       axi$1_awlock;
	input  [3:0]                axi$1_awcache;
	input  [2:0]                axi$1_awprot;
	input  [3:0]                axi$1_awqos;
	input  [3:0]                axi$1_awregion;
	input                       axi$1_awvalid;
	output                      axi$1_awready;
	// write data channel
	input  [${4:/*data width*/}:0]              axi$1_wdata;
	input  [${5:/*strb width*/}:0]               axi$1_wstrb;
	input                       axi$1_wlast;
	input                       axi$1_wvalid;
	output                      axi$1_wready;
	// write response channel
	output [$2:0]               axi$1_bid;
	output [1:0]                axi$1_bresp;
	output                      axi$1_bvalid;
	input                       axi$1_bready;
	// read address channel
	input  [$2:0]               axi$1_arid;
	input  [$3:0]               axi$1_araddr;
	input  [7:0]                axi$1_arlen;
	input  [2:0]                axi$1_arsize;
	input  [1:0]                axi$1_arburst;
	input                       axi$1_arlock;
	input  [3:0]                axi$1_arcache;
	input  [2:0]                axi$1_arprot;
	input  [3:0]                axi$1_arqos;
	input  [3:0]                axi$1_arregion;
	input                       axi$1_arvalid;
	output                      axi$1_arready;
	// read data channel
	input  [$2:0]               axi$1_rid;
	input  [$4:0]              axi$1_rdata;
	output [1:0]                axi$1_rresp;
	input                       axi$1_rlast;
	input                       axi$1_rvalid;
	output                      axi$1_rready;


snippet axi3
	// AMBA AXI bus versison:3 ----------------------------------
	// global signal
	input                       axi${1:/*seq num*/}_aclk;
	input                       axi$1_aresetn;
	// write address channel
	input  [${2:/*id width*/}:0]               axi$1_awid;
	input  [${3:/*addr width*/}:0]               axi$1_awaddr;
	input  [3:0]                axi$1_awlen;
	input  [2:0]                axi$1_awsize;
	input  [1:0]                axi$1_awburst;
	input  [1:0]                axi$1_awlock;
	input  [3:0]                axi$1_awcache;
	input  [2:0]                axi$1_awprot;
	input                       axi$1_awvalid;
	output                      axi$1_awready;
	// write data channel
	input  [$2:0]               axi$1_wid;
	input  [${4:/*data width*/}:0]               axi$1_wdata;
	input  [${5:/*strb width*/}:0]               axi$1_wstrb;
	input                       axi$1_wlast;
	input                       axi$1_wvalid;
	output                      axi$1_wready;
	// write response channel
	output [$2:0]               axi$1_bid;
	output [1:0]                axi$1_bresp;
	output                      axi$1_bvalid;
	input                       axi$1_bready;
	// read address channel
	input  [$2:0]               axi$1_arid;
	input  [$3:0]               axi$1_araddr;
	input  [7:0]                axi$1_arlen;
	input  [2:0]                axi$1_arsize;
	input  [1:0]                axi$1_arburst;
	input                       axi$1_arlock;
	input  [3:0]                axi$1_arcache;
	input  [2:0]                axi$1_arprot;
	input                       axi$1_arvalid;
	output                      axi$1_arready;
	// read data channel
	input  [$2:0]               axi$1_rid;
	input  [$4:0]               axi$1_rdata;
	output [1:0]                axi$1_rresp;
	input                       axi$1_rlast;
	input                       axi$1_rvalid;
	output                      axi$1_rready;


